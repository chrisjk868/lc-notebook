# 977. Squares of a Sorted Array
***Topics***: *Sorting, Array*  
***Difficulty***: <span style="color: #46c6c2;">Easy</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an integer array `nums` sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

---
**Example 1:**  
Input: `nums = [-4,-1,0,3,10]`  
Output: `[0,1,9,16,100]`  
Explanation: `After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100].`  

**Example 2:**  
Input: `nums = [-7,-3,2,3,11]`  
Output: `[4,9,9,49,121]`  

---
## Intuition
The important point here is that we need to realize the differences in terms of order that squaring positive and negative numbers would yield. When we square positive numbers they would remain in the same order, however when we square negative numbers they would be in the reverse order compared to the original if we want elements to be in ascending order.

With a 2 pointers approach we could sort the elements of both squared positive and negative numbers array into a single array in $\mathcal{O}(N)$ time.

> 2 Pointers approach of merging 2 sorted array togther:
> - if `pos[p_pointer] >= neg[n_pointer]` append `neg[n_pointer]` to `ans` array
> - if `pos[p_pointer] < neg[n_pointer]` append `pos[p_pointer]` to `ans` array
> ---

After merging both sorted `pos` and `neg` arrays into one overall sorted array `ans` we can just return that as our final answer to the problem.

---
## Implementation
[implementation]

---
## Solution
```python
def sortedSquares(self, nums: List[int]) -> List[int]:
    # O(N) time solution:
    # - Negative in reverse
    # - Positives in same order
    pos, neg, ans = [], [], []
    p_pointer, n_pointer = 0, 0
    for i in range(len(nums)):
        if nums[i] < 0:
            neg.append(nums[i] ** 2)
        else:
            pos.append(nums[i] ** 2)
    neg = neg[::-1]
    # 2 Pointers
    while p_pointer < len(pos) and n_pointer < len(neg):
        # Compare pos and neg number
        if pos[p_pointer] >= neg[n_pointer]:
            ans.append(neg[n_pointer])
            n_pointer += 1
        else:
            ans.append(pos[p_pointer])
            p_pointer += 1
    # Handle edge cases:
    if p_pointer <= len(pos) - 1:
        ans += pos[p_pointer:]
    elif n_pointer <= len(neg) - 1:
        ans += neg[n_pointer:]
    return ans
```
---
## Runtime & Space Complexity
$[parameter]$ ~ being in `[parameter]`.  

Runtime Complexity:  
$\mathcal{O}(N)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![[lc number] code performance](../../resources/code-performances/lc-977.png)

---