# 253. Meeting Rooms II
***Topics***: *Heap, Greedy, Queue*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an array of meeting time `intervals` intervals where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.

---
**Example 1:**  

Input: `intervals = [[0,30],[5,10],[15,20]]`  
Output: `2`  

**Example 2:**  

Input: `intervals = [[7,10],[2,4]]`  
Output: `1`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
import heapq
def minMeetingRooms(self, intervals: List[List[int]]) -> int:
    # 1 conference room could only host 1 meeting at a time
    # You want to fit as many disjoint meetings into 1 room as much as possible
    # Count insertions into min heap
    min_heap = []
    heapq.heapify(min_heap)
    intervals.sort(key=lambda x:x[0])
    rooms = 0
    for start, end in intervals:
        if not min_heap:
            rooms += 1
            heapq.heappush(min_heap, [end, start])
        else:
            # Get the earliest available room
            e, s = heapq.heappop(min_heap)
            if e <= start:
                heapq.heappush(min_heap, [end, start])
            else:
                rooms += 1
                heapq.heappush(min_heap, [end, start])
                heapq.heappush(min_heap, [e, s])
    return rooms
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `intervals`.  

Runtime Complexity:  
$\mathcal{O}(N \cdot log(N))$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![253 code performance](../y_resources/code-performances/lc-253.png)

---