# 100. Same Tree
***Topics***: *Tree, Depth First Search*  
***Difficulty***: <span style="color: #46c6c2;">Easy</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

---
**Example 1:**  

![example 1 image](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

Input: `p = [1,2,3], q = [1,2,3]`  
Output: `true`  

**Example 2:**  

![example 2 image](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

Input: `p = [1,2], q = [1,null,2]`  
Output: `false`  

**Example 3:**  

![example 3 image](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

Input: `p = [1,2,1], q = [1,1,2]`  
Output: `false`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    # Check if tree is the same with dfs traversal
    def dfs(p, q):
        if not p and not q:
            return True
        elif (not p and q) or (p and not q):
            return False
        l = dfs(p.left, q.left)
        r = dfs(p.right, q.right)
        return (p.val == q.val) and (l and r)
    return dfs(p, q)
```
---
## Runtime & Space Complexity
$[parameter]$ ~ being in ```[parameter]```.  

Runtime Complexity:  
$\mathcal{O}()$

[explanation]

Space Complexity:  
$\mathcal{O}()$

[explanation]

---
## Code Performance
![[lc number] code performance](path/to/file)

---