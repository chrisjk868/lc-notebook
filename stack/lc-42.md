# 42. Trapping Rain Water
***Topics***: *Stack, Monotonic Stack*  
***Difficulty***: <span style="color: #f8615c;">Hard</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.


---
**Example 1:**  

![example 1](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

Input: `height = [0,1,0,2,1,0,1,3,2,1,2,1]`  
Output: `6`  
Explanation: `The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.`  

**Example 2:**  

Input: `height = [0,1,0,2,1,0,1,3,2,1,2,1]`  
Output: `6`  
Explanation: `The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.`  

---
## Intuition
For this problem we can approach the problem in 2 different ways. I will explain both approaches here. I believe the first to be more intuitive, and allows you to figure out the second solution using a monotonic stack.

Firstly, we need to understand how we can find the total amount of water that could be possible trapped at any given index `i`.

We know that the amount of water that could be trapped at a certain index `i` of `height[i]` is determined by the max height on the current cells left hand side and the max height on the current cells right hand side.

Therefore at every `i` we can calculate the total units of water trapped by:  
`water_height[i] = min(max(height[:i]), max(height[i + 1:])) - height[i]`

**Approach 1: Dynamic Programming**

So from this we could clearly see that the first approach would be a dynamic programming approach to the problem.

**Optimal Substructure:**
- What is the maximum water height that could be achieved at index `i`.

**Overlapping Subproblems:**
- What is the maximum height on the left and on the right of index `i`.

Therefore with the dynamic programming approach we could construct a prefix array that `p`, where at each `i` it tells us the maximal height observed up until `i` ~ `max(height[:i + 1])`, and we could also initalize a suffix array that tells us the maximal height observed from the right of `i` up until `i` ~ `max(height[i:])`.

With this we could just iterate through the `height` array as is and and every `i` we look at `i - 1` of `p` and `i + 1` of `s` to find the minimal max heights possible for trapping water at `i` and add that result to our `ans`.

**Approach 2: Monotonic Stack**

---
## Implementation
[implementation]

---
## Solution
**Approach 1:**
```python
def trap(self, height: List[int]) -> int:
    # Construct a prefix and suffix array representing height maxes seen up until now
    p, s = [0] * len(height), [0] * len(height)
    p[0], s[-1] = height[0], height[-1]
    ans = 0
    for i in range(1, len(height)):
        p[i] = max(height[i], p[i - 1])
    for i in range(len(height) - 2, -1, -1):
        s[i] = max(height[i], s[i + 1])
    for i in range(1, len(height) - 1):
        min_h = min(p[i - 1], s[i + 1])
        ans += min_h - height[i] if min_h > height[i] else 0
    return ans
```

**Approach 2:**
```python
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `height`.  

Runtime Complexity:  
$\mathcal{O}(N)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![42 code performance](../y_resources/code-performances/lc-42.png)

---