# 253. Meeting Rooms II
***Topics***: *Heap, Greedy*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an array of meeting time `intervals` intervals where `intervals[i] = [start_i, end_i]`, return the minimum number of conference rooms required.

---
**Example 1:**  

Input: `intervals = [[0,30],[5,10],[15,20]]`  
Output: `2`  

**Example 2:**  

Input: `intervals = [[7,10],[2,4]]`  
Output: `1`  

---
## Intuition
For this problem it doesn't really matter which room is free or not. As long as a room is free we could always use it. The only problem really arises when no rooms are free and when we need to assign a new room to fill in for a specific meeting in `intervals`.

In this case, we want to always get the earliest room that is available which would be open for new meetings as we schedule each meeting chronologically. Logically speaking we want meetings with earlier start times to be prioritized first.

This means that we could first sort the given `intervals` array by start time first and afterwards process each interval one by one.

Before we iterate through our `intervals` array we would also initialize a heap which keeps track of the earliest available room, ordered by their end times. This means we would want a min heap to achieve this purpose.

As we iterate through our sorted `intervals` array for our current `[start_i, end_i]` if the

---
## Implementation
[implementation]

---
## Solution
```python
import heapq
def minMeetingRooms(self, intervals: List[List[int]]) -> int:
    # 1 conference room could only host 1 meeting at a time
    # You want to fit as many disjoint meetings into 1 room as much as possible
    # Count insertions into min heap
    min_heap = []
    heapq.heapify(min_heap)
    intervals.sort(key=lambda x:x[0])
    rooms = 0
    for start, end in intervals:
        if not min_heap:
            rooms += 1
            heapq.heappush(min_heap, [end, start])
        else:
            # Get the earliest available room
            e, s = heapq.heappop(min_heap)
            if e <= start:
                heapq.heappush(min_heap, [end, start])
            else:
                rooms += 1
                heapq.heappush(min_heap, [end, start])
                heapq.heappush(min_heap, [e, s])
    return rooms
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `intervals`.  

Runtime Complexity:  
$\mathcal{O}(N \cdot log(N))$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![253 code performance](../y_resources/code-performances/lc-253.png)

---