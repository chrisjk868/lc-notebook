# 673. Number of Longest Increasing Subsequence
***Topics***: *Dynammic Programming*, *Array*   
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an integer array `nums`, return the number of longest increasing subsequences.

Notice that the sequence has to be **strictly** increasing.

Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.

---
**Example 1:**  

Input: `nums = [1,3,5,4,7]`  
Output: `2`  
Explanation: `The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].`  

**Example 2:**  

Input: `nums = [2,2,2,2,2]`  
Output: `5`  
Explanation: `The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
def findNumberOfLIS(self, nums: List[int]) -> int:
    """
    At i:
        - What is the number of longest increasing subsequences that we could make up to i?
    """
    dp = [1] * len(nums)
    cnt = [1] * len(nums)
    max_len = 1
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                if dp[j] + 1 == dp[i]:
                    cnt[i] += cnt[j]
                if dp[j] + 1 > dp[i]:
                    dp[i] = 1 + dp[j]
                    cnt[i] = cnt[j]
        max_len = max(max_len, dp[i])
    ans = 0
    for i in range(len(cnt)):
        if dp[i] == max_len:
            ans += cnt[i]
    return ans
```
---
## Runtime & Space Complexity
$[parameter]$ ~ being in `[parameter]`.  

Runtime Complexity:  
$\mathcal{O}(N^2)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![673 code performance](../../resources/code-performances/lc-673.png)

---