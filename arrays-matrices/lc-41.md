# 41. First Missing Positive
***Topics***: *Array*  
***Difficulty***: <span style="color: #f8615c;">Hard</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an unsorted integer array `nums`. Return the smallest positive integer that is not present in `nums`.

You must implement an algorithm that runs in `O(n)` time and uses `O(1)` auxiliary space.

---
**Example 1:**  

Input: `nums = [1,2,0]`  
Output: `3`  
Explanation: `The numbers in the range [1,2] are all in the array.`  

**Example 2:**  

Input: `nums = [3,4,-1,1]`  
Output: `2`  
Explanation: `1 is in the array but 2 is missing.`  

**Example 3:**  

Input: `nums = [7,8,9,11,12]`  
Output: `1`  
Explanation: `The smallest positive integer 1 is missing.`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
def firstMissingPositive(self, nums: List[int]) -> int:
    highest, smallest = max(nums), min(nums)
    if smallest > 1 or highest <= 0:
        return 1
    for i in range(len(nums)):
        if nums[i] <= 0:
            nums[i] = highest + 2
    for i in range(len(nums)):
        idx = abs(nums[i]) - 1
        if idx < len(nums):
            nums[idx] *= -1 if nums[idx] > 0 else 1
    for i in range(len(nums)):
        if nums[i] > 0:
            return i + 1
    return highest + 1
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `nums`.  

Runtime Complexity:  
$\mathcal{O}(N)$

Runtime is linear because we are only at most iterating through each element of `nums` once.

Space Complexity:  
$\mathcal{O}(1)$

No extra space here is used so it is constant.

---
## Code Performance
![41 code performance](../y_resources/code-performances/lc-41.png)

---