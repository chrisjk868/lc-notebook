# 678. Valid Parenthesis String
***Topics***: *Stack, Greedy*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` if `s` is **valid**.

The following rules define a valid string:

- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
- `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""`.


---
**Example 1:**  

Input: `()`  
Output: `true`  

**Example 2:**  

Input: `(*)`  
Output: `true`

**Example 3:**  

Input: `(*))`  
Output: `true`

---
## Intuition
The difficulty in this problem lies in the addition of using `'*'`. And they function as some sort of wildcard in this case. As they could be either a closed or open bracket or an empty string.

Since the problem comes down to successfully matching all open brackets with close brackets, we could try and keep track of open brackets. However, we want to do this in exhaustive manner with a greedy approach to the problem.

Greedy Approach:
- Keep `'*'` for as long as possible
- Exhaust available open brackets first when close brackets are encountered
- Exhaust available asterisks when we don't have open brackets once we encounter close brackets

---
## Implementation
[implementation]

---
## Solution
```python
def checkValidString(self, s: str) -> bool:
    # When would we use up an asteriks?
    # Keep the asteriks for as long as possible
    # Using 2 stacks
    open_b = []
    ast = []
    for i in range(len(s)):
        cur = s[i]
        if cur == '(':
            open_b.append((cur, i))
        elif cur == ')':
            if open_b:
                open_b.pop()
            else:
                if not ast:
                    return False
                else:
                    ast.pop()
        else:
            ast.append((cur, i))
    while open_b and ast:
        if open_b[-1][-1] > ast[-1][-1]:
            return False
        open_b.pop()
        ast.pop()
    return False if open_b else True
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input string `s`.  

Runtime Complexity:  
$\mathcal{O}(N)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![678 code performance](../y_resources/code-performances/lc-678.png)

---