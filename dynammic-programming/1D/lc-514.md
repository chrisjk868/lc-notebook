# 514. Freedom Trail
***Topics***: *Dynamic Programming, Depth First Search*  
***Difficulty***: <span style="color: #f8615c;">Hard</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring" and use the dial to spell a specific keyword to open the door.

Given a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at the `"12:00"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `"12:00"` direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character `key[i]`:

1. You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the `"12:00"` direction, where this character must equal `key[i]`.  
2. If the character `key[i]` has been aligned at the `"12:00"` direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.

---
**Example 1:**  

![example 1](https://assets.leetcode.com/uploads/2018/10/22/ring.jpg)

Input: `[input]`  
Output: `[output]`  
Explanation: `[explanation]`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
def findRotateSteps(self, ring: str, key: str) -> int:
    # Firstly find a way to calculate the minimal number of steps of getting ~
    # from one character to the next with progressing clockwise or anticlockwise ~
    # with scenario of wrapping around the gvien ring array
    def get_min_steps(cur_i, tar_i):
        dist = abs(tar_i - cur_i)
        around = len(ring) - dist
        return min(dist, around)
    # Memoization:
    dp = {}
    # Use DFS to enumerate all possible dial revolutions
    # At each turn you want to turn to the next matching key from the current ring character at 12:00
    def turn(ring_idx, key_idx):
        if (ring_idx, key_idx) in dp:
            return dp[(ring_idx,key_idx)]
        # If our key_idx exceeds the length of key that means we have done matching all keys from ring
        if key_idx >= len(key):
            return 0
        # For the current ring_idx: being the current character at 12:00 ~
        # we want to find all occurences of the matching key[key_idx] which is ~
        # the next key we need to match
        mv = inf
        for i in range(len(ring)):
            if ring[i] == key[key_idx]:
                # Calculate the minimal moves needed to get from ring_idx to ring[i]
                cur_mv = 1 + get_min_steps(ring_idx, i) + turn(i, key_idx + 1)
                mv = min(mv, 1 + get_min_steps(ring_idx, i) + turn(i, key_idx + 1))
        dp[(ring_idx, key_idx)] = mv
        return mv
    return turn(0, 0)
```
---
## Runtime & Space Complexity
$N$ ~ being the length of `key`.
$M$ ~ being the length of `ring`.  

Runtime Complexity:  
$\mathcal{O}(N \cdot M)$

[explanation]

Space Complexity:  
$\mathcal{O}(N \cdot M)$

[explanation]

---
## Code Performance
![514 code performance](../../y_resources/code-performances/lc-514.png)

---