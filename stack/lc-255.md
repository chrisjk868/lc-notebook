# 255. Verify Preorder Sequence in Binary Search Tree
***Topics***: *Stack, Monotonic Stack*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an array of unique integers `preorder`, return `true` if it is the correct preorder traversal sequence of a binary search tree.

---
**Example 1:**  

![ lc 255 example 1 ](https://assets.leetcode.com/uploads/2021/03/12/preorder-tree.jpg)

Input: `preorder = [5,2,1,3,6]`  
Output: `true`  

**Example 2:**  

Input: `preorder = [5,2,6,1,3]`  
Output: `false`  

---
## Intuition
This question is quite hard to explain with words, it is best for me to illustrate the thought process for this question. The implementation is very simple but the logic behind this problem is more complex.

Firstly, let us look at the BST invariant:
For a `node`:
- All values in `node.left` is smaller than `node.val`
- All values in `node.right` is greater than `node.val`

Since preorder traversal handles the node first before its children, this makes traversing the tree a lot easier with the use of a stack.

We can consider the following scenarios where we traverse down the left subtrees of each node:

- If we are given `preorder = [5, 3, 2, 1, 3]`. The first value `5` must be the root, this is because we using a preorder traversal. Afterwards we can compare `5` with the next value in the list which is `2`. Since `2 < 5` this means that `2` must be in the left subtree of node `5` to uphold the BST invariant. We do the same for node `1` until we reach `3`.
![](https://assets.leetcode.com/static_assets/media/original_images/255/1.png)  
- At this point `3` cannot be to left of node `1` this is because `3 > 1`. In a preorder traversal we visit the node, visit left and lastly visit right. So in a preorder traversal this node would exist as the right child of node `2` which is the parent of node `1`, which makes sense because the childs of the most recent parent node would be processed first.
![](https://assets.leetcode.com/static_assets/media/original_images/255/2.png)  

![](https://assets.leetcode.com/static_assets/media/original_images/255/3.png)  
![](https://assets.leetcode.com/static_assets/media/original_images/255/4.png)  
![](https://assets.leetcode.com/static_assets/media/original_images/255/5.png)  

---
## Implementation
[implementation]

---
## Solution
```python
from collections import deque
def verifyPreorder(self, preorder: List[int]) -> bool:
    min_limit = -inf
    stack = deque()
    # Maintain a monotonically decreasing stack
    # The stack represents everything that is to the left hand side of the tree
    # When we append to stack we are visitng the (left child) of the node on top of the stack
    # When we pop from the stack we have finished visiting the left subtree of the popped node
    # As soon as we find a node with value that is larger

    for num in preorder:
        while stack and num > stack[-1]:
            min_limit = stack.pop()
        if num <= min_limit:
            return False
        stack.append(num)
    return True
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `preorder`.  

Runtime Complexity:  
$\mathcal{O}(N)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![255 code performance](../y_resources/code-performances/lc-255..png)

---