# 221. Maximal Square
***Topics***: *Dynamic Programming, Array, Matrix*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.


---
**Example 1:**  
![example 1](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

Input: `matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]`  
Output: `4`

**Example 2:**  
![example 2](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

Input: `matrix = [["0","1"],["1","0"]]`  
Output: `1`

**Example 3:**
Input: `matrix = [["0"]]`  
Output: `0`

---
## Intuition
This problem is definitely a dynamic programming question. We can examine exactly why:
- Optimal Substructure:
    - At each arbitrary square `(i,j)` we want to know what is the maximal square area that could be formed.
- Overlapping Subproblems:
    - At each square we want to know the optimal area formed in previous squares, and the optimal area let's for square at `(i, j)` would have already been calculated first and for the square at `(i - 1, j)` we wouldn't need to bother with re-computing the maximal area formed at square `(i, j)` for calculating its maximal square area.

For this problem I will present both the ***(Bottom - up) Tabulation*** approach and ***(Top - down) Memoization*** approach. 

---
## Implementation
[implementation]

---
## Solution
```python
[python code]
```
---
## Runtime & Space Complexity
$[parameter]$ ~ being in `[parameter]`.  

Runtime Complexity:  
$\mathcal{O}()$

[explanation]

Space Complexity:  
$\mathcal{O}()$

[explanation]

---
## Code Performance
![[lc number] code performance](path/to/file)

---