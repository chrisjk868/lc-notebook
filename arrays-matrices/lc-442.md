# 442. Find All Duplicates in an Array
***Topics***: *Array, Hashmap*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears once or twice, return an array of all the integers that appears twice.

You must write an algorithm that runs in `O(n)` time and uses only constant extra space.

---
**Example 1:**  
Input: `nums = [4,3,2,7,8,2,3,1]`  
Output: `[2,3]`    

**Example 2:**  
Input: `[1,1,2]`  
Output: `[1]`  

**Example 3:**  
Input: `[1]`  
Output: `[]`  

---
## Intuition
For this problem if we intend to solve it in linear time and constant space we could try to alter the existing elements of the given `nums` array. 

---
## Implementation
[implementation]

---
## Solution
```python
def findDuplicates(self, nums: List[int]) -> List[int]:
    ans = []
    for i, num in enumerate(nums):
        if nums[abs(num) - 1] > 0:
            nums[abs(num) - 1] *= -1
        else:
            ans.append(abs(num))
    return ans
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `nums`.  

Runtime Complexity:  
$\mathcal{O}(N)$

Linear time because we are iterating pass every element in `nums` at most once.

Space Complexity:  
$\mathcal{O}(1)$

Constant space because no extra space is being used.

---
## Code Performance
![442 code performance](../y_resources/code-performances/lc-442.png)

---