# 979. Distribute Coins in Binary Tree
***Topics***: *[topics]*  
***Difficulty***: <span style="color: #46c6c2;">[difficulty]</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
[problem statement]

---
**Example 1:**  

![example 1](https://assets.leetcode.com/uploads/2019/01/18/tree1.png)
 
Input: `root = [3, 0, 0]`   
Output: `2`  
Explanation: `From the root of the tree, we move one coin to its left child, and one coin to its right child.`  

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
def distributeCoins(self, root: Optional[TreeNode]) -> int:
    moves = [0]
    def dfs(node):
        if not node:
            return 0
        # Coins recieved from the left
        left = dfs(node.left) 
        # Coins recieved from the right
        right = dfs(node.right) 
        # Moves needed by the current node to redistribute coins after recieving them
        moves[0] += abs(left) + abs(right) 
        if not node.val:
            return left + right - 1
        elif node.val == 1:
            return left + right
        else:
            return node.val + left + right - 1
    dfs(root)
    return moves[0]
```
---
## Runtime & Space Complexity
$[parameter]$ ~ being in `[parameter]`.  

Runtime Complexity:  
$\mathcal{O}()$

[explanation]

Space Complexity:  
$\mathcal{O}()$

[explanation]

---
## Code Performance
![[lc number] code performance](path/to/file)

---