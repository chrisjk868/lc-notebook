# 525. Contiguous Array
***Topics***: *Array, Prefix Sum, Hash Table*  
***Difficulty***: <span style="color: #fac31d;">Medium</span>
<!-- green: #46c6c2, yellow: #fac31d, red: #f8615c-->
---
Given a binary array `nums`, return the maximum length of a contiguous subarray with an equal number of `0` and `1`.

---
**Example 1:**  
Input: `nums = [0,1]`  
Output: `2`  
Explanation: `[0, 1] is the longest contiguous subarray with an equal number of 0 and 1.`  

**Example 2:**  
Input: `nums = [0,1,0]`  
Output: `2`  
Explanation: `[0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.`

---
## Intuition
[intuition]

---
## Implementation
[implementation]

---
## Solution
```python
def findMaxLength(self, nums: List[int]) -> int:
    p = [0] * len(nums)
    ans = 0
    for i in range(len(nums)):
        nums[i] = -1 if nums[i] == 0 else nums[i]
    p[0] = nums[0]
    for i in range(1, len(p)):
        p[i] = nums[i] + p[i - 1]
    arr_sums = {}
    for j in range(len(p)):
        if p[j] == 0:
            ans = max(ans, j + 1)
        if p[j] in arr_sums:
            arr_len = j - arr_sums[p[j]][0]
            ans = max(ans, arr_len)
            arr_sums[p[j]].append(j)
        else:
            arr_sums[p[j]] = [j] 
    return ans
```
---
## Runtime & Space Complexity
$N$ ~ being the size of input array `nums`.  

Runtime Complexity:  
$\mathcal{O}(N)$

[explanation]

Space Complexity:  
$\mathcal{O}(N)$

[explanation]

---
## Code Performance
![525 code performance](../../resources/code-performances/lc-525.png)

---